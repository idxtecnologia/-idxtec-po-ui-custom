import { EventEmitter, Input, Output, Directive } from '@angular/core';
import { convertToInt, isTypeof } from '../../utils/util';
import { PoChartType } from './enums/po-chart-type.enum';
import { PoColorService } from '../../services/po-color/po-color.service';
const poChartDefaultHeight = 400;
const poChartMinHeight = 200;
/**
 * @description
 *
 * O `po-chart` é um componente para renderização de dados através de gráficos, com isso facilitando a compreensão e tornando a
 * visualização destes dados mais agradável.
 *
 * Através de suas principais propriedades é possível definir atributos, tais como tipo de gráfico, altura, título, cores customizadas, opções para os eixos, entre outros.
 *
 * O componente permite utilizar em conjunto séries do tipo linha e coluna.
 *
 * Além disso, também é possível definir uma ação que será executada ao clicar em determinado elemento do gráfico
 * e outra que será executada ao passar o *mouse* sobre o elemento.
 *
 * #### Guia de uso para Gráficos
 *
 * > Veja nosso [guia de uso para gráficos](/guides/guide-charts) para auxiliar na construção do seu gráfico,
 * informando em qual caso utilizar, o que devemos evitar e boas práticas relacionada a cores.
 */
export class PoChartBaseComponent {
    constructor(colorService) {
        this.colorService = colorService;
        /**
         * @optional
         *
         * @description
         *
         * Evento executado quando o usuário clicar sobre um elemento do gráfico.
         *
         * O evento emitirá o seguinte parâmetro:
         * - *donut* e *pie*: um objeto contendo a categoria e valor da série.
         * - *area*, *line*, *column* e *bar*: um objeto contendo o nome da série, valor e categoria do eixo do gráfico.
         */
        this.seriesClick = new EventEmitter();
        /**
         * @optional
         *
         * @description
         *
         * Evento executado quando o usuário passar o *mouse* sobre um elemento do gráfico.
         *
         * O evento emitirá o seguinte parâmetro de acordo com o tipo de gráfico:
         * - *donut* e *pie*: um objeto contendo a categoria e valor da série.
         * - *area*, *line*, *column* e *bar*: um objeto contendo a categoria, valor da série e categoria do eixo do gráfico.
         */
        this.seriesHover = new EventEmitter();
        // manipulação das séries tratadas internamente para preservar 'p-series';
        this.chartSeries = [];
    }
    /**
     * @optional
     *
     * @description
     *
     * Define a altura do gráfico.
     *
     * > O valor mínimo aceito nesta propriedade é 200.
     *
     * @default `400px`
     */
    set height(value) {
        const intValue = convertToInt(value);
        let height;
        if (isTypeof(value, 'number')) {
            height = intValue <= poChartMinHeight ? poChartMinHeight : intValue;
        }
        else {
            height = this.setDefaultHeight();
        }
        this._height = height;
        this.getSvgContainerSize();
        this.rebuildComponentRef();
    }
    get height() {
        return this._height || this.setDefaultHeight();
    }
    /**
     * @optional
     *
     * @description
     *
     * Define o tipo de gráfico.
     *
     * É possível também combinar gráficos dos tipos linha e coluna. Para isso, opte pela declaração de `type` conforme a interface `PoChartSerie`.
     *
     * > Note que, se houver declaração de tipo de gráfico tanto em `p-type` quanto em `PochartSerie.type`, o valor `{ type }` da primeira série anulará o valor definido em `p-type`.
     *
     * Se não passado valor, o padrão será relativo à primeira série passada em `p-series`:
     * - Se `p-series = [{ data: [1,2,3] }]`: será `PoChartType.Column`.
     * - Se `p-series = [{ data: 1 }]`: será `PoChartType.Pie`.
     *
     * > Veja os valores válidos no *enum* `PoChartType`.
     */
    set type(value) {
        // O Valor default definido em `p-series` de acordo com a primeira série passada.
        this._type = Object.values(PoChartType).includes(value) ? value : undefined;
        this.rebuildComponentRef();
    }
    get type() {
        return this._type;
    }
    /**
     * @description
     *
     * Define os elementos do gráfico que serão criados dinamicamente.
     */
    set series(value) {
        this._series = value || [];
        if (Array.isArray(this._series) && this._series.length) {
            this.setTypeDefault(this._series[0]);
        }
        else {
            this.transformObjectToArrayObject(this.series);
            this.rebuildComponentRef();
        }
    }
    get series() {
        return this._series;
    }
    /**
     * @optional
     *
     * @description
     *
     * Define os nomes das categorias que serão plotadas no eixo X do gráfico caso seja do tipo `bar`, ou então nos eixos Y do grid de gráficos dos tipos `area`, `columnn` e `line`.
     *
     * > Gráficos do tipo `bar` dimensionam a área do gráfico de acordo com a largura do maior texto de categorias. No entanto, é uma boa prática optar por palavras curtas para que a leitura do gráfico não seja prejudicada.
     *
     * > Caso não seja especificado um valor para a categoria, será plotado um hífen na categoria referente a cada série.
     */
    set categories(value) {
        if (Array.isArray(value)) {
            this._categories = value;
        }
    }
    get categories() {
        return this._categories;
    }
    /**
     * @optional
     *
     * @description
     *
     * Objeto com as configurações usadas no `po-chart`.
     *
     * É possível, por exemplo, definir as configurações de exibição das legendas,
     * configurar os eixos(*axis*) para os gráficos dos tipos `area`, `line`, `column` e `bar` da seguinte forma:
     *
     * ```
     *  chartOptions: PoChartOptions = {
     *    legend: true,
     *    axis: {
     *      minRange: 0,
     *      maxRange: 100,
     *      gridLines: 5,
     *    },
     *  };
     * ```
     */
    set options(value) {
        if (value instanceof Object && !(value instanceof Array)) {
            this._options = value;
            if (this._options.hasOwnProperty('legend') && typeof this._options.legend === 'boolean') {
                this.getSvgContainerSize();
            }
        }
    }
    get options() {
        return this._options;
    }
    get isTypeCircular() {
        return this.defaultType === PoChartType.Pie || this.defaultType === PoChartType.Donut;
    }
    ngOnChanges(changes) {
        const isArrayOfseries = Array.isArray(this.series) && this.series.length > 0;
        if ((changes.series && isArrayOfseries) ||
            (changes.type && isArrayOfseries) ||
            (changes.categories && isArrayOfseries)) {
            this.validateSerieAndAddType(this.series);
        }
        if ((changes.type && !this.isTypeCircular) || (changes.categories && !this.isTypeCircular)) {
            this.svgContainerSize = Object.assign(Object.assign({}, this.svgContainerSize), { axisXLabelWidth: this.calculateAxisXLabelArea() });
        }
    }
    onSeriesClick(event) {
        this.seriesClick.emit(event);
    }
    onSeriesHover(event) {
        this.seriesHover.emit(event);
    }
    setDefaultHeight() {
        return this.type === PoChartType.Gauge ? poChartMinHeight : poChartDefaultHeight;
    }
    transformObjectToArrayObject(serie) {
        this.chartSeries = typeof serie === 'object' && Object.keys(serie).length ? [Object.assign({}, serie)] : [];
    }
    setTypeDefault(serie) {
        var _a;
        const data = (_a = serie.data) !== null && _a !== void 0 ? _a : serie.value;
        const serieType = Object.values(PoChartType).includes(serie.type) ? serie.type : undefined;
        this.defaultType = serieType ? serieType : Array.isArray(data) ? PoChartType.Column : PoChartType.Pie;
    }
    validateSerieAndAddType(series) {
        const filteredSeries = series.filter(serie => this.isTypeCircular
            ? typeof serie.data === 'number' || typeof serie.value === 'number'
            : Array.isArray(serie.data));
        this.chartSeries = this.appendType(this.appendColors(filteredSeries));
    }
    appendColors(series) {
        return this.colorService.getColors(series);
    }
    appendType(series) {
        return series.map((serie, index) => {
            if (index === 0) {
                this.chartType = Object.values(PoChartType).includes(serie.type)
                    ? serie.type
                    : this.type || this.defaultType;
            }
            return Object.assign(Object.assign({}, serie), { type: serie.type || this.chartType });
        });
    }
}
PoChartBaseComponent.decorators = [
    { type: Directive }
];
PoChartBaseComponent.ctorParameters = () => [
    { type: PoColorService }
];
PoChartBaseComponent.propDecorators = {
    title: [{ type: Input, args: ['p-title',] }],
    seriesClick: [{ type: Output, args: ['p-series-click',] }],
    seriesHover: [{ type: Output, args: ['p-series-hover',] }],
    height: [{ type: Input, args: ['p-height',] }],
    type: [{ type: Input, args: ['p-type',] }],
    series: [{ type: Input, args: ['p-series',] }],
    categories: [{ type: Input, args: ['p-categories',] }],
    options: [{ type: Input, args: ['p-options',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tY2hhcnQtYmFzZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy91aS9zcmMvbGliL2NvbXBvbmVudHMvcG8tY2hhcnQvcG8tY2hhcnQtYmFzZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBNEIsTUFBTSxlQUFlLENBQUM7QUFFakcsT0FBTyxFQUFFLFlBQVksRUFBRSxRQUFRLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUkxRCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFHekQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDBDQUEwQyxDQUFDO0FBRTFFLE1BQU0sb0JBQW9CLEdBQUcsR0FBRyxDQUFDO0FBQ2pDLE1BQU0sZ0JBQWdCLEdBQUcsR0FBRyxDQUFDO0FBRTdCOzs7Ozs7Ozs7Ozs7Ozs7OztHQWlCRztBQUVILE1BQU0sT0FBZ0Isb0JBQW9CO0lBb0x4QyxZQUFzQixZQUE0QjtRQUE1QixpQkFBWSxHQUFaLFlBQVksQ0FBZ0I7UUFoTGxEOzs7Ozs7Ozs7O1dBVUc7UUFFSCxnQkFBVyxHQUFHLElBQUksWUFBWSxFQUFvQyxDQUFDO1FBRW5FOzs7Ozs7Ozs7O1dBVUc7UUFFSCxnQkFBVyxHQUFHLElBQUksWUFBWSxFQUFvQyxDQUFDO1FBRW5FLDBFQUEwRTtRQUMxRSxnQkFBVyxHQUE0QyxFQUFFLENBQUM7SUFtSkwsQ0FBQztJQXZJdEQ7Ozs7Ozs7Ozs7T0FVRztJQUNILElBQXVCLE1BQU0sQ0FBQyxLQUFhO1FBQ3pDLE1BQU0sUUFBUSxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNyQyxJQUFJLE1BQWMsQ0FBQztRQUVuQixJQUFJLFFBQVEsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLEVBQUU7WUFDN0IsTUFBTSxH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QUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUU7WUFDakMsSUFBSSxLQUFLLEtBQUssQ0FBQyxFQUFFO2dCQUNmLElBQUksQ0FBQyxTQUFTLEdBQVMsTUFBTyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQztvQkFDckUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJO29CQUNaLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUM7YUFDbkM7WUFFRCx1Q0FBWSxLQUFLLEtBQUUsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLFNBQVMsSUFBRztRQUMxRCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7OztZQTdQRixTQUFTOzs7WUF2QkQsY0FBYzs7O29CQTBCcEIsS0FBSyxTQUFDLFNBQVM7MEJBYWYsTUFBTSxTQUFDLGdCQUFnQjswQkFjdkIsTUFBTSxTQUFDLGdCQUFnQjtxQkEyQnZCLEtBQUssU0FBQyxVQUFVO21CQXFDaEIsS0FBSyxTQUFDLFFBQVE7cUJBZ0JkLEtBQUssU0FBQyxVQUFVO3lCQTBCaEIsS0FBSyxTQUFDLGNBQWM7c0JBK0JwQixLQUFLLFNBQUMsV0FBVyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgRGlyZWN0aXZlLCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgY29udmVydFRvSW50LCBpc1R5cGVvZiB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWwnO1xuXG5pbXBvcnQgeyBQb0NoYXJ0Q29udGFpbmVyU2l6ZSB9IGZyb20gJy4vaW50ZXJmYWNlcy9wby1jaGFydC1jb250YWluZXItc2l6ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUG9DaGFydEdhdWdlU2VyaWUgfSBmcm9tICcuL3BvLWNoYXJ0LXR5cGVzL3BvLWNoYXJ0LWdhdWdlL3BvLWNoYXJ0LWdhdWdlLXNlcmllcy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUG9DaGFydFR5cGUgfSBmcm9tICcuL2VudW1zL3BvLWNoYXJ0LXR5cGUuZW51bSc7XG5pbXBvcnQgeyBQb0NoYXJ0T3B0aW9ucyB9IGZyb20gJy4vaW50ZXJmYWNlcy9wby1jaGFydC1vcHRpb25zLmludGVyZmFjZSc7XG5pbXBvcnQgeyBQb0NoYXJ0U2VyaWUgfSBmcm9tICcuL2ludGVyZmFjZXMvcG8tY2hhcnQtc2VyaWUuaW50ZXJmYWNlJztcbmltcG9ydCB7IFBvQ29sb3JTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvcG8tY29sb3IvcG8tY29sb3Iuc2VydmljZSc7XG5cbmNvbnN0IHBvQ2hhcnREZWZhdWx0SGVpZ2h0ID0gNDAwO1xuY29uc3QgcG9DaGFydE1pbkhlaWdodCA9IDIwMDtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBPIGBwby1jaGFydGAgw6kgdW0gY29tcG9uZW50ZSBwYXJhIHJlbmRlcml6YcOnw6NvIGRlIGRhZG9zIGF0cmF2w6lzIGRlIGdyw6FmaWNvcywgY29tIGlzc28gZmFjaWxpdGFuZG8gYSBjb21wcmVlbnPDo28gZSB0b3JuYW5kbyBhXG4gKiB2aXN1YWxpemHDp8OjbyBkZXN0ZXMgZGFkb3MgbWFpcyBhZ3JhZMOhdmVsLlxuICpcbiAqIEF0cmF2w6lzIGRlIHN1YXMgcHJpbmNpcGFpcyBwcm9wcmllZGFkZXMgw6kgcG9zc8OtdmVsIGRlZmluaXIgYXRyaWJ1dG9zLCB0YWlzIGNvbW8gdGlwbyBkZSBncsOhZmljbywgYWx0dXJhLCB0w610dWxvLCBjb3JlcyBjdXN0b21pemFkYXMsIG9ww6fDtWVzIHBhcmEgb3MgZWl4b3MsIGVudHJlIG91dHJvcy5cbiAqXG4gKiBPIGNvbXBvbmVudGUgcGVybWl0ZSB1dGlsaXphciBlbSBjb25qdW50byBzw6lyaWVzIGRvIHRpcG8gbGluaGEgZSBjb2x1bmEuXG4gKlxuICogQWzDqW0gZGlzc28sIHRhbWLDqW0gw6kgcG9zc8OtdmVsIGRlZmluaXIgdW1hIGHDp8OjbyBxdWUgc2Vyw6EgZXhlY3V0YWRhIGFvIGNsaWNhciBlbSBkZXRlcm1pbmFkbyBlbGVtZW50byBkbyBncsOhZmljb1xuICogZSBvdXRyYSBxdWUgc2Vyw6EgZXhlY3V0YWRhIGFvIHBhc3NhciBvICptb3VzZSogc29icmUgbyBlbGVtZW50by5cbiAqXG4gKiAjIyMjIEd1aWEgZGUgdXNvIHBhcmEgR3LDoWZpY29zXG4gKlxuICogPiBWZWphIG5vc3NvIFtndWlhIGRlIHVzbyBwYXJhIGdyw6FmaWNvc10oL2d1aWRlcy9ndWlkZS1jaGFydHMpIHBhcmEgYXV4aWxpYXIgbmEgY29uc3RydcOnw6NvIGRvIHNldSBncsOhZmljbyxcbiAqIGluZm9ybWFuZG8gZW0gcXVhbCBjYXNvIHV0aWxpemFyLCBvIHF1ZSBkZXZlbW9zIGV2aXRhciBlIGJvYXMgcHLDoXRpY2FzIHJlbGFjaW9uYWRhIGEgY29yZXMuXG4gKi9cbkBEaXJlY3RpdmUoKVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBvQ2hhcnRCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgLyoqIERlZmluZSBvIHTDrXR1bG8gZG8gZ3LDoWZpY28uICovXG4gIEBJbnB1dCgncC10aXRsZScpIHRpdGxlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIEV2ZW50byBleGVjdXRhZG8gcXVhbmRvIG8gdXN1w6FyaW8gY2xpY2FyIHNvYnJlIHVtIGVsZW1lbnRvIGRvIGdyw6FmaWNvLlxuICAgKlxuICAgKiBPIGV2ZW50byBlbWl0aXLDoSBvIHNlZ3VpbnRlIHBhcsOibWV0cm86XG4gICAqIC0gKmRvbnV0KiBlICpwaWUqOiB1bSBvYmpldG8gY29udGVuZG8gYSBjYXRlZ29yaWEgZSB2YWxvciBkYSBzw6lyaWUuXG4gICAqIC0gKmFyZWEqLCAqbGluZSosICpjb2x1bW4qIGUgKmJhcio6IHVtIG9iamV0byBjb250ZW5kbyBvIG5vbWUgZGEgc8OpcmllLCB2YWxvciBlIGNhdGVnb3JpYSBkbyBlaXhvIGRvIGdyw6FmaWNvLlxuICAgKi9cbiAgQE91dHB1dCgncC1zZXJpZXMtY2xpY2snKVxuICBzZXJpZXNDbGljayA9IG5ldyBFdmVudEVtaXR0ZXI8UG9DaGFydFNlcmllIHwgUG9DaGFydEdhdWdlU2VyaWU+KCk7XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogRXZlbnRvIGV4ZWN1dGFkbyBxdWFuZG8gbyB1c3XDoXJpbyBwYXNzYXIgbyAqbW91c2UqIHNvYnJlIHVtIGVsZW1lbnRvIGRvIGdyw6FmaWNvLlxuICAgKlxuICAgKiBPIGV2ZW50byBlbWl0aXLDoSBvIHNlZ3VpbnRlIHBhcsOibWV0cm8gZGUgYWNvcmRvIGNvbSBvIHRpcG8gZGUgZ3LDoWZpY286XG4gICAqIC0gKmRvbnV0KiBlICpwaWUqOiB1bSBvYmpldG8gY29udGVuZG8gYSBjYXRlZ29yaWEgZSB2YWxvciBkYSBzw6lyaWUuXG4gICAqIC0gKmFyZWEqLCAqbGluZSosICpjb2x1bW4qIGUgKmJhcio6IHVtIG9iamV0byBjb250ZW5kbyBhIGNhdGVnb3JpYSwgdmFsb3IgZGEgc8OpcmllIGUgY2F0ZWdvcmlhIGRvIGVpeG8gZG8gZ3LDoWZpY28uXG4gICAqL1xuICBAT3V0cHV0KCdwLXNlcmllcy1ob3ZlcicpXG4gIHNlcmllc0hvdmVyID0gbmV3IEV2ZW50RW1pdHRlcjxQb0NoYXJ0U2VyaWUgfCBQb0NoYXJ0R2F1Z2VTZXJpZT4oKTtcblxuICAvLyBtYW5pcHVsYcOnw6NvIGRhcyBzw6lyaWVzIHRyYXRhZGFzIGludGVybmFtZW50ZSBwYXJhIHByZXNlcnZhciAncC1zZXJpZXMnO1xuICBjaGFydFNlcmllczogQXJyYXk8UG9DaGFydFNlcmllIHwgUG9DaGFydEdhdWdlU2VyaWU+ID0gW107XG4gIGNoYXJ0VHlwZTogUG9DaGFydFR5cGU7XG4gIHN2Z0NvbnRhaW5lclNpemU6IFBvQ2hhcnRDb250YWluZXJTaXplO1xuXG4gIHByaXZhdGUgX29wdGlvbnM6IFBvQ2hhcnRPcHRpb25zO1xuICBwcml2YXRlIF9jYXRlZ29yaWVzOiBBcnJheTxzdHJpbmc+O1xuICBwcml2YXRlIF9oZWlnaHQ6IG51bWJlcjtcbiAgcHJpdmF0ZSBfc2VyaWVzOiBBcnJheTxQb0NoYXJ0U2VyaWU+IHwgUG9DaGFydEdhdWdlU2VyaWU7XG4gIHByaXZhdGUgX3R5cGU6IFBvQ2hhcnRUeXBlO1xuXG4gIHByaXZhdGUgZGVmYXVsdFR5cGU6IFBvQ2hhcnRUeXBlO1xuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIERlZmluZSBhIGFsdHVyYSBkbyBncsOhZmljby5cbiAgICpcbiAgICogPiBPIHZhbG9yIG3DrW5pbW8gYWNlaXRvIG5lc3RhIHByb3ByaWVkYWRlIMOpIDIwMC5cbiAgICpcbiAgICogQGRlZmF1bHQgYDQwMHB4YFxuICAgKi9cbiAgQElucHV0KCdwLWhlaWdodCcpIHNldCBoZWlnaHQodmFsdWU6IG51bWJlcikge1xuICAgIGNvbnN0IGludFZhbHVlID0gY29udmVydFRvSW50KHZhbHVlKTtcbiAgICBsZXQgaGVpZ2h0OiBudW1iZXI7XG5cbiAgICBpZiAoaXNUeXBlb2YodmFsdWUsICdudW1iZXInKSkge1xuICAgICAgaGVpZ2h0ID0gaW50VmFsdWUgPD0gcG9DaGFydE1pbkhlaWdodCA/IHBvQ2hhcnRNaW5IZWlnaHQgOiBpbnRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0ID0gdGhpcy5zZXREZWZhdWx0SGVpZ2h0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy5nZXRTdmdDb250YWluZXJTaXplKCk7XG4gICAgdGhpcy5yZWJ1aWxkQ29tcG9uZW50UmVmKCk7XG4gIH1cblxuICBnZXQgaGVpZ2h0KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2hlaWdodCB8fCB0aGlzLnNldERlZmF1bHRIZWlnaHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIERlZmluZSBvIHRpcG8gZGUgZ3LDoWZpY28uXG4gICAqXG4gICAqIMOJIHBvc3PDrXZlbCB0YW1iw6ltIGNvbWJpbmFyIGdyw6FmaWNvcyBkb3MgdGlwb3MgbGluaGEgZSBjb2x1bmEuIFBhcmEgaXNzbywgb3B0ZSBwZWxhIGRlY2xhcmHDp8OjbyBkZSBgdHlwZWAgY29uZm9ybWUgYSBpbnRlcmZhY2UgYFBvQ2hhcnRTZXJpZWAuXG4gICAqXG4gICAqID4gTm90ZSBxdWUsIHNlIGhvdXZlciBkZWNsYXJhw6fDo28gZGUgdGlwbyBkZSBncsOhZmljbyB0YW50byBlbSBgcC10eXBlYCBxdWFudG8gZW0gYFBvY2hhcnRTZXJpZS50eXBlYCwgbyB2YWxvciBgeyB0eXBlIH1gIGRhIHByaW1laXJhIHPDqXJpZSBhbnVsYXLDoSBvIHZhbG9yIGRlZmluaWRvIGVtIGBwLXR5cGVgLlxuICAgKlxuICAgKiBTZSBuw6NvIHBhc3NhZG8gdmFsb3IsIG8gcGFkcsOjbyBzZXLDoSByZWxhdGl2byDDoCBwcmltZWlyYSBzw6lyaWUgcGFzc2FkYSBlbSBgcC1zZXJpZXNgOlxuICAgKiAtIFNlIGBwLXNlcmllcyA9IFt7IGRhdGE6IFsxLDIsM10gfV1gOiBzZXLDoSBgUG9DaGFydFR5cGUuQ29sdW1uYC5cbiAgICogLSBTZSBgcC1zZXJpZXMgPSBbeyBkYXRhOiAxIH1dYDogc2Vyw6EgYFBvQ2hhcnRUeXBlLlBpZWAuXG4gICAqXG4gICAqID4gVmVqYSBvcyB2YWxvcmVzIHbDoWxpZG9zIG5vICplbnVtKiBgUG9DaGFydFR5cGVgLlxuICAgKi9cbiAgQElucHV0KCdwLXR5cGUnKSBzZXQgdHlwZSh2YWx1ZTogUG9DaGFydFR5cGUpIHtcbiAgICAvLyBPIFZhbG9yIGRlZmF1bHQgZGVmaW5pZG8gZW0gYHAtc2VyaWVzYCBkZSBhY29yZG8gY29tIGEgcHJpbWVpcmEgc8OpcmllIHBhc3NhZGEuXG4gICAgdGhpcy5fdHlwZSA9ICg8YW55Pk9iamVjdCkudmFsdWVzKFBvQ2hhcnRUeXBlKS5pbmNsdWRlcyh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcblxuICAgIHRoaXMucmVidWlsZENvbXBvbmVudFJlZigpO1xuICB9XG5cbiAgZ2V0IHR5cGUoKTogUG9DaGFydFR5cGUge1xuICAgIHJldHVybiB0aGlzLl90eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBEZWZpbmUgb3MgZWxlbWVudG9zIGRvIGdyw6FmaWNvIHF1ZSBzZXLDo28gY3JpYWRvcyBkaW5hbWljYW1lbnRlLlxuICAgKi9cbiAgQElucHV0KCdwLXNlcmllcycpIHNldCBzZXJpZXModmFsdWU6IEFycmF5PFBvQ2hhcnRTZXJpZT4gfCBQb0NoYXJ0R2F1Z2VTZXJpZSkge1xuICAgIHRoaXMuX3NlcmllcyA9IHZhbHVlIHx8IFtdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5fc2VyaWVzKSAmJiB0aGlzLl9zZXJpZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnNldFR5cGVEZWZhdWx0KHRoaXMuX3Nlcmllc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtT2JqZWN0VG9BcnJheU9iamVjdCh0aGlzLnNlcmllcyBhcyBQb0NoYXJ0R2F1Z2VTZXJpZSk7XG4gICAgICB0aGlzLnJlYnVpbGRDb21wb25lbnRSZWYoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgc2VyaWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXJpZXM7XG4gIH1cblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBEZWZpbmUgb3Mgbm9tZXMgZGFzIGNhdGVnb3JpYXMgcXVlIHNlcsOjbyBwbG90YWRhcyBubyBlaXhvIFggZG8gZ3LDoWZpY28gY2FzbyBzZWphIGRvIHRpcG8gYGJhcmAsIG91IGVudMOjbyBub3MgZWl4b3MgWSBkbyBncmlkIGRlIGdyw6FmaWNvcyBkb3MgdGlwb3MgYGFyZWFgLCBgY29sdW1ubmAgZSBgbGluZWAuXG4gICAqXG4gICAqID4gR3LDoWZpY29zIGRvIHRpcG8gYGJhcmAgZGltZW5zaW9uYW0gYSDDoXJlYSBkbyBncsOhZmljbyBkZSBhY29yZG8gY29tIGEgbGFyZ3VyYSBkbyBtYWlvciB0ZXh0byBkZSBjYXRlZ29yaWFzLiBObyBlbnRhbnRvLCDDqSB1bWEgYm9hIHByw6F0aWNhIG9wdGFyIHBvciBwYWxhdnJhcyBjdXJ0YXMgcGFyYSBxdWUgYSBsZWl0dXJhIGRvIGdyw6FmaWNvIG7Do28gc2VqYSBwcmVqdWRpY2FkYS5cbiAgICpcbiAgICogPiBDYXNvIG7Do28gc2VqYSBlc3BlY2lmaWNhZG8gdW0gdmFsb3IgcGFyYSBhIGNhdGVnb3JpYSwgc2Vyw6EgcGxvdGFkbyB1bSBow61mZW4gbmEgY2F0ZWdvcmlhIHJlZmVyZW50ZSBhIGNhZGEgc8OpcmllLlxuICAgKi9cbiAgQElucHV0KCdwLWNhdGVnb3JpZXMnKSBzZXQgY2F0ZWdvcmllcyh2YWx1ZTogQXJyYXk8c3RyaW5nPikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhpcy5fY2F0ZWdvcmllcyA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGdldCBjYXRlZ29yaWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9jYXRlZ29yaWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogT2JqZXRvIGNvbSBhcyBjb25maWd1cmHDp8O1ZXMgdXNhZGFzIG5vIGBwby1jaGFydGAuXG4gICAqXG4gICAqIMOJIHBvc3PDrXZlbCwgcG9yIGV4ZW1wbG8sIGRlZmluaXIgYXMgY29uZmlndXJhw6fDtWVzIGRlIGV4aWJpw6fDo28gZGFzIGxlZ2VuZGFzLFxuICAgKiBjb25maWd1cmFyIG9zIGVpeG9zKCpheGlzKikgcGFyYSBvcyBncsOhZmljb3MgZG9zIHRpcG9zIGBhcmVhYCwgYGxpbmVgLCBgY29sdW1uYCBlIGBiYXJgIGRhIHNlZ3VpbnRlIGZvcm1hOlxuICAgKlxuICAgKiBgYGBcbiAgICogIGNoYXJ0T3B0aW9uczogUG9DaGFydE9wdGlvbnMgPSB7XG4gICAqICAgIGxlZ2VuZDogdHJ1ZSxcbiAgICogICAgYXhpczoge1xuICAgKiAgICAgIG1pblJhbmdlOiAwLFxuICAgKiAgICAgIG1heFJhbmdlOiAxMDAsXG4gICAqICAgICAgZ3JpZExpbmVzOiA1LFxuICAgKiAgICB9LFxuICAgKiAgfTtcbiAgICogYGBgXG4gICAqL1xuICBASW5wdXQoJ3Atb3B0aW9ucycpIHNldCBvcHRpb25zKHZhbHVlOiBQb0NoYXJ0T3B0aW9ucykge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCAmJiAhKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICB0aGlzLl9vcHRpb25zID0gdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLmhhc093blByb3BlcnR5KCdsZWdlbmQnKSAmJiB0eXBlb2YgdGhpcy5fb3B0aW9ucy5sZWdlbmQgPT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLmdldFN2Z0NvbnRhaW5lclNpemUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBjb2xvclNlcnZpY2U6IFBvQ29sb3JTZXJ2aWNlKSB7fVxuXG4gIGdldCBpc1R5cGVDaXJjdWxhcigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0VHlwZSA9PT0gUG9DaGFydFR5cGUuUGllIHx8IHRoaXMuZGVmYXVsdFR5cGUgPT09IFBvQ2hhcnRUeXBlLkRvbnV0O1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGNvbnN0IGlzQXJyYXlPZnNlcmllcyA9IEFycmF5LmlzQXJyYXkodGhpcy5zZXJpZXMpICYmIHRoaXMuc2VyaWVzLmxlbmd0aCA+IDA7XG5cbiAgICBpZiAoXG4gICAgICAoY2hhbmdlcy5zZXJpZXMgJiYgaXNBcnJheU9mc2VyaWVzKSB8fFxuICAgICAgKGNoYW5nZXMudHlwZSAmJiBpc0FycmF5T2ZzZXJpZXMpIHx8XG4gICAgICAoY2hhbmdlcy5jYXRlZ29yaWVzICYmIGlzQXJyYXlPZnNlcmllcylcbiAgICApIHtcbiAgICAgIHRoaXMudmFsaWRhdGVTZXJpZUFuZEFkZFR5cGUodGhpcy5zZXJpZXMgYXMgQXJyYXk8UG9DaGFydFNlcmllPik7XG4gICAgfVxuXG4gICAgaWYgKChjaGFuZ2VzLnR5cGUgJiYgIXRoaXMuaXNUeXBlQ2lyY3VsYXIpIHx8IChjaGFuZ2VzLmNhdGVnb3JpZXMgJiYgIXRoaXMuaXNUeXBlQ2lyY3VsYXIpKSB7XG4gICAgICB0aGlzLnN2Z0NvbnRhaW5lclNpemUgPSB7XG4gICAgICAgIC4uLnRoaXMuc3ZnQ29udGFpbmVyU2l6ZSxcbiAgICAgICAgYXhpc1hMYWJlbFdpZHRoOiB0aGlzLmNhbGN1bGF0ZUF4aXNYTGFiZWxBcmVhKClcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgb25TZXJpZXNDbGljayhldmVudDogYW55KTogdm9pZCB7XG4gICAgdGhpcy5zZXJpZXNDbGljay5lbWl0KGV2ZW50KTtcbiAgfVxuXG4gIG9uU2VyaWVzSG92ZXIoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuc2VyaWVzSG92ZXIuZW1pdChldmVudCk7XG4gIH1cblxuICBwcml2YXRlIHNldERlZmF1bHRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gUG9DaGFydFR5cGUuR2F1Z2UgPyBwb0NoYXJ0TWluSGVpZ2h0IDogcG9DaGFydERlZmF1bHRIZWlnaHQ7XG4gIH1cblxuICBwcml2YXRlIHRyYW5zZm9ybU9iamVjdFRvQXJyYXlPYmplY3Qoc2VyaWU6IFBvQ2hhcnRHYXVnZVNlcmllKSB7XG4gICAgdGhpcy5jaGFydFNlcmllcyA9IHR5cGVvZiBzZXJpZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoc2VyaWUpLmxlbmd0aCA/IFt7IC4uLnNlcmllIH1dIDogW107XG4gIH1cblxuICBwcml2YXRlIHNldFR5cGVEZWZhdWx0KHNlcmllOiBQb0NoYXJ0U2VyaWUpIHtcbiAgICBjb25zdCBkYXRhID0gc2VyaWUuZGF0YSA/PyBzZXJpZS52YWx1ZTtcbiAgICBjb25zdCBzZXJpZVR5cGUgPSAoPGFueT5PYmplY3QpLnZhbHVlcyhQb0NoYXJ0VHlwZSkuaW5jbHVkZXMoc2VyaWUudHlwZSkgPyBzZXJpZS50eXBlIDogdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5kZWZhdWx0VHlwZSA9IHNlcmllVHlwZSA/IHNlcmllVHlwZSA6IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBQb0NoYXJ0VHlwZS5Db2x1bW4gOiBQb0NoYXJ0VHlwZS5QaWU7XG4gIH1cblxuICBwcml2YXRlIHZhbGlkYXRlU2VyaWVBbmRBZGRUeXBlKHNlcmllczogQXJyYXk8UG9DaGFydFNlcmllPik6IHZvaWQge1xuICAgIGNvbnN0IGZpbHRlcmVkU2VyaWVzID0gc2VyaWVzLmZpbHRlcihzZXJpZSA9PlxuICAgICAgdGhpcy5pc1R5cGVDaXJjdWxhclxuICAgICAgICA/IHR5cGVvZiBzZXJpZS5kYXRhID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygc2VyaWUudmFsdWUgPT09ICdudW1iZXInXG4gICAgICAgIDogQXJyYXkuaXNBcnJheShzZXJpZS5kYXRhKVxuICAgICk7XG5cbiAgICB0aGlzLmNoYXJ0U2VyaWVzID0gdGhpcy5hcHBlbmRUeXBlKHRoaXMuYXBwZW5kQ29sb3JzKGZpbHRlcmVkU2VyaWVzKSk7XG4gIH1cblxuICBwcml2YXRlIGFwcGVuZENvbG9ycyhzZXJpZXM6IEFycmF5PFBvQ2hhcnRTZXJpZT4pIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvclNlcnZpY2UuZ2V0Q29sb3JzPFBvQ2hhcnRTZXJpZT4oc2VyaWVzKTtcbiAgfVxuXG4gIHByaXZhdGUgYXBwZW5kVHlwZShzZXJpZXM6IEFycmF5PFBvQ2hhcnRTZXJpZT4pIHtcbiAgICByZXR1cm4gc2VyaWVzLm1hcCgoc2VyaWUsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSAoPGFueT5PYmplY3QpLnZhbHVlcyhQb0NoYXJ0VHlwZSkuaW5jbHVkZXMoc2VyaWUudHlwZSlcbiAgICAgICAgICA/IHNlcmllLnR5cGVcbiAgICAgICAgICA6IHRoaXMudHlwZSB8fCB0aGlzLmRlZmF1bHRUeXBlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyAuLi5zZXJpZSwgdHlwZTogc2VyaWUudHlwZSB8fCB0aGlzLmNoYXJ0VHlwZSB9O1xuICAgIH0pO1xuICB9XG5cbiAgYWJzdHJhY3QgcmVidWlsZENvbXBvbmVudFJlZigpOiB2b2lkO1xuXG4gIC8vIHbDoWxpZG8gcGFyYSBncsOhZmljb3MgZG8gdGlwbyBjaXJjdWxhciBlIHF1ZSBzZXLDoSByZWZhdG9yYWRvLlxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0U3ZnQ29udGFpbmVyU2l6ZSgpOiB2b2lkO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgY2FsY3VsYXRlQXhpc1hMYWJlbEFyZWEoKTogbnVtYmVyO1xufVxuIl19