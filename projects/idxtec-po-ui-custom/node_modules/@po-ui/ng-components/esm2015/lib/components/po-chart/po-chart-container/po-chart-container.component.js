import { Component, EventEmitter, Input, Output, ViewChild } from '@angular/core';
import { PoChartType } from '../enums/po-chart-type.enum';
import { PoChartMathsService } from '../services/po-chart-maths.service';
export class PoChartContainerComponent {
    constructor(mathsService) {
        this.mathsService = mathsService;
        this.serieClick = new EventEmitter();
        this.serieHover = new EventEmitter();
        this._series = [];
    }
    set options(value) {
        if (value instanceof Object && !(value instanceof Array)) {
            this._options = value;
            this.verifyAxisOptions(this._options);
        }
    }
    get options() {
        return this._options;
    }
    set series(data) {
        this._series = data;
        this.setAlignByTheCorners(this._series);
        this.setSeriesByType(this._series);
        this.setRange(this._series, this.options);
    }
    get series() {
        return this._series;
    }
    get isTypeCircular() {
        return this.type === PoChartType.Pie || this.type === PoChartType.Donut;
    }
    ngOnChanges(changes) {
        if (changes.type || changes.containerSize) {
            this.setViewBox();
            this.setSvgSpace();
        }
    }
    getCategoriesCoordinates(value) {
        this.categoriesCoordinates = value;
    }
    onSerieClick(event) {
        this.serieClick.emit(event);
    }
    onSerieHover(event) {
        this.serieHover.emit(event);
    }
    getRange(series, options = {}) {
        var _a, _b, _c;
        const domain = this.mathsService.calculateMinAndMaxValues(series);
        const minValue = !((_a = options.axis) === null || _a === void 0 ? void 0 : _a.minRange) && domain.minValue > 0
            ? 0
            : ((_b = options.axis) === null || _b === void 0 ? void 0 : _b.minRange) < domain.minValue
                ? options.axis.minRange
                : domain.minValue;
        const maxValue = ((_c = options.axis) === null || _c === void 0 ? void 0 : _c.maxRange) > domain.maxValue ? options.axis.maxRange : domain.maxValue;
        const updatedDomainValues = { minValue, maxValue };
        return Object.assign(Object.assign({}, domain), updatedDomainValues);
    }
    setSvgSpace() {
        var _a;
        // Representa um ponto 2D dentro do viewport do SVG. Ele é a representação do cursor do mouse para comparação de coordenadas com cada dado de série.
        const svgPoint = this.svgELement.nativeElement.createSVGPoint();
        // Retorna um DOMMatrix representando as matrizes 2D e 3D transformadas a partir das coordenadas do elemento, em relação ao document, para coordenadas relativas ao viewport do SVG.
        // É utilizado nos gráficos do tipo área para que seja possível equiparar as coordenadas do evento com cada dado de série, para assim ativar o ponto de dado equivalente.
        const svgDomMatrix = (_a = this.svgELement.nativeElement.getScreenCTM()) === null || _a === void 0 ? void 0 : _a.inverse();
        this.svgSpace = { svgPoint, svgDomMatrix };
    }
    setAlignByTheCorners(series) {
        this.alignByTheCorners = series.every(serie => serie.type === PoChartType.Area || serie.type === PoChartType.Bar);
    }
    setRange(series, options = {}) {
        if (!this.isTypeCircular) {
            this.range = this.getRange(series, options);
        }
    }
    setSeriesByType(series) {
        this.seriesByType = {
            [PoChartType.Area]: series.filter(serie => serie.type === PoChartType.Area),
            [PoChartType.Column]: series.filter(serie => serie.type === PoChartType.Column),
            [PoChartType.Bar]: series.filter(serie => serie.type === PoChartType.Bar),
            [PoChartType.Line]: series.filter(serie => serie.type === PoChartType.Line),
            [PoChartType.Donut]: series.filter(serie => serie.type === PoChartType.Donut),
            [PoChartType.Pie]: series.filter(serie => serie.type === PoChartType.Pie)
        };
    }
    setViewBox() {
        const { svgWidth, svgHeight } = this.containerSize;
        const viewBoxWidth = this.isTypeCircular ? svgHeight : svgWidth;
        // Tratamento necessário para que não corte o vetor nas extremidades
        const offsetXY = 1;
        this.viewBox = `${offsetXY} -${offsetXY} ${viewBoxWidth} ${this.containerSize.svgHeight}`;
    }
    verifyAxisOptions(options) {
        if (!this.isTypeCircular && options.hasOwnProperty('axis')) {
            this.range = this.getRange(this.series, this.options);
            this.axisOptions = Object.assign(Object.assign({}, this.axisOptions), options.axis);
        }
    }
}
PoChartContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'po-chart-container',
                template: "<svg:svg\n  #svgELement\n  class=\"po-chart-svg-element\"\n  preserveAspectRatio=\"xMidYMin meet\"\n  [attr.viewBox]=\"viewBox\"\n  [attr.width]=\"containerSize.svgWidth\"\n  [attr.height]=\"containerSize.svgHeight\"\n>\n  <!-- axis -->\n  <svg:g\n    *ngIf=\"!isTypeCircular\"\n    po-chart-axis\n    [p-align-by-the-corners]=\"alignByTheCorners\"\n    [p-range]=\"range\"\n    [p-type]=\"type\"\n    [p-series]=\"series\"\n    [p-container-size]=\"containerSize\"\n    [p-options]=\"axisOptions\"\n    [p-categories]=\"categories\"\n    (p-categories-coordinates)=\"getCategoriesCoordinates($event)\"\n  ></svg:g>\n\n  <!-- chart area -->\n  <svg:g\n    *ngIf=\"(type === 'area' || type === 'line' || type === 'column') && seriesByType['area'].length\"\n    po-chart-area\n    [p-align-by-the-corners]=\"alignByTheCorners\"\n    [p-svg-space]=\"svgSpace\"\n    [p-categories]=\"categories\"\n    [p-categories-coordinates]=\"categoriesCoordinates\"\n    [p-range]=\"range\"\n    [p-series]=\"seriesByType['area']\"\n    [p-container-size]=\"containerSize\"\n    (p-bar-hover)=\"onSerieHover($event)\"\n    (p-bar-click)=\"onSerieClick($event)\"\n  ></svg:g>\n\n  <!-- chart column -->\n  <svg:g\n    *ngIf=\"(type === 'area' || type === 'line' || type === 'column') && seriesByType['column'].length\"\n    po-chart-column\n    [p-categories]=\"categories\"\n    [p-range]=\"range\"\n    [p-series]=\"seriesByType['column']\"\n    [p-container-size]=\"containerSize\"\n    (p-bar-hover)=\"onSerieHover($event)\"\n    (p-bar-click)=\"onSerieClick($event)\"\n  ></svg:g>\n\n  <!-- chart line -->\n  <svg:g\n    *ngIf=\"(type === 'area' || type === 'line' || type === 'column') && seriesByType['line'].length\"\n    po-chart-line\n    [p-categories]=\"categories\"\n    [p-range]=\"range\"\n    [p-series]=\"seriesByType['line']\"\n    [p-container-size]=\"containerSize\"\n    (p-point-hover)=\"onSerieHover($event)\"\n    (p-point-click)=\"onSerieClick($event)\"\n  ></svg:g>\n\n  <!-- chart bar -->\n  <svg:g\n    *ngIf=\"type === 'bar'\"\n    po-chart-bar\n    [p-categories]=\"categories\"\n    [p-range]=\"range\"\n    [p-series]=\"seriesByType['bar']\"\n    [p-container-size]=\"containerSize\"\n    (p-bar-hover)=\"onSerieHover($event)\"\n    (p-bar-click)=\"onSerieClick($event)\"\n  ></svg:g>\n\n  <svg:g\n    *ngIf=\"type === 'pie'\"\n    po-chart-pie\n    [p-series]=\"seriesByType['pie']\"\n    [p-container-size]=\"containerSize\"\n    (p-circular-hover)=\"onSerieHover($event)\"\n    (p-circular-click)=\"onSerieClick($event)\"\n  ></svg:g>\n\n  <svg:g\n    *ngIf=\"type === 'donut'\"\n    po-chart-donut\n    [p-options]=\"options\"\n    [p-series]=\"seriesByType['donut']\"\n    [p-container-size]=\"containerSize\"\n    (p-circular-hover)=\"onSerieHover($event)\"\n    (p-circular-click)=\"onSerieClick($event)\"\n  ></svg:g>\n</svg:svg>\n"
            },] }
];
PoChartContainerComponent.ctorParameters = () => [
    { type: PoChartMathsService }
];
PoChartContainerComponent.propDecorators = {
    categories: [{ type: Input, args: ['p-categories',] }],
    type: [{ type: Input, args: ['p-type',] }],
    containerSize: [{ type: Input, args: ['p-container-size',] }],
    serieClick: [{ type: Output, args: ['p-serie-click',] }],
    serieHover: [{ type: Output, args: ['p-serie-hover',] }],
    svgELement: [{ type: ViewChild, args: ['svgELement', { static: true },] }],
    options: [{ type: Input, args: ['p-options',] }],
    series: [{ type: Input, args: ['p-series',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tY2hhcnQtY29udGFpbmVyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3VpL3NyYy9saWIvY29tcG9uZW50cy9wby1jaGFydC9wby1jaGFydC1jb250YWluZXIvcG8tY2hhcnQtY29udGFpbmVyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFjLFlBQVksRUFBRSxLQUFLLEVBQWEsTUFBTSxFQUFpQixTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFeEgsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBSTFELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBUXpFLE1BQU0sT0FBTyx5QkFBeUI7SUFtRHBDLFlBQW9CLFlBQWlDO1FBQWpDLGlCQUFZLEdBQVosWUFBWSxDQUFxQjtRQTVDNUIsZUFBVSxHQUFHLElBQUksWUFBWSxFQUFPLENBQUM7UUFFckMsZUFBVSxHQUFHLElBQUksWUFBWSxFQUFPLENBQUM7UUFhdEQsWUFBTyxHQUF3QixFQUFFLENBQUM7SUE2QmMsQ0FBQztJQTNCekQsSUFBd0IsT0FBTyxDQUFDLEtBQXFCO1FBQ25ELElBQUksS0FBSyxZQUFZLE1BQU0sSUFBSSxDQUFDLENBQUMsS0FBSyxZQUFZLEtBQUssQ0FBQyxFQUFFO1lBQ3hELElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1lBRXRCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDdkM7SUFDSCxDQUFDO0lBRUQsSUFBSSxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxJQUF1QixNQUFNLENBQUMsSUFBeUI7UUFDckQsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFDcEIsSUFBSSxD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LCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uQ2hhbmdlcywgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzLCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgUG9DaGFydFR5cGUgfSBmcm9tICcuLi9lbnVtcy9wby1jaGFydC10eXBlLmVudW0nO1xuaW1wb3J0IHsgUG9DaGFydENvbnRhaW5lclNpemUgfSBmcm9tICcuLi9pbnRlcmZhY2VzL3BvLWNoYXJ0LWNvbnRhaW5lci1zaXplLmludGVyZmFjZSc7XG5pbXBvcnQgeyBQb0NoYXJ0T3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvcG8tY2hhcnQtb3B0aW9ucy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUG9DaGFydEF4aXNPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9wby1jaGFydC1heGlzLW9wdGlvbnMuaW50ZXJmYWNlJztcbmltcG9ydCB7IFBvQ2hhcnRNYXRoc1NlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9wby1jaGFydC1tYXRocy5zZXJ2aWNlJztcbmltcG9ydCB7IFBvQ2hhcnRNaW5NYXhWYWx1ZXMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL3BvLWNoYXJ0LW1pbi1tYXgtdmFsdWVzLmludGVyZmFjZSc7XG5pbXBvcnQgeyBQb0NoYXJ0U2VyaWUgfSBmcm9tICcuLi9pbnRlcmZhY2VzL3BvLWNoYXJ0LXNlcmllLmludGVyZmFjZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3BvLWNoYXJ0LWNvbnRhaW5lcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9wby1jaGFydC1jb250YWluZXIuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIFBvQ2hhcnRDb250YWluZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBASW5wdXQoJ3AtY2F0ZWdvcmllcycpIGNhdGVnb3JpZXM6IEFycmF5PHN0cmluZz47XG5cbiAgQElucHV0KCdwLXR5cGUnKSB0eXBlOiBQb0NoYXJ0VHlwZTtcblxuICBASW5wdXQoJ3AtY29udGFpbmVyLXNpemUnKSBjb250YWluZXJTaXplOiBQb0NoYXJ0Q29udGFpbmVyU2l6ZTtcblxuICBAT3V0cHV0KCdwLXNlcmllLWNsaWNrJykgc2VyaWVDbGljayA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIEBPdXRwdXQoJ3Atc2VyaWUtaG92ZXInKSBzZXJpZUhvdmVyID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgQFZpZXdDaGlsZCgnc3ZnRUxlbWVudCcsIHsgc3RhdGljOiB0cnVlIH0pIHN2Z0VMZW1lbnQ6IEVsZW1lbnRSZWY7XG5cbiAgYWxpZ25CeVRoZUNvcm5lcnM6IGJvb2xlYW47XG4gIGF4aXNPcHRpb25zOiBQb0NoYXJ0QXhpc09wdGlvbnM7XG4gIGNhdGVnb3JpZXNDb29yZGluYXRlczogQXJyYXk8bnVtYmVyPjtcbiAgcmFuZ2U6IFBvQ2hhcnRNaW5NYXhWYWx1ZXM7XG4gIHNlcmllc0J5VHlwZTtcbiAgc3ZnU3BhY2U7XG4gIHZpZXdCb3g6IHN0cmluZztcblxuICBwcml2YXRlIF9vcHRpb25zOiBQb0NoYXJ0T3B0aW9ucztcbiAgcHJpdmF0ZSBfc2VyaWVzOiBBcnJheTxQb0NoYXJ0U2VyaWU+ID0gW107XG5cbiAgQElucHV0KCdwLW9wdGlvbnMnKSBzZXQgb3B0aW9ucyh2YWx1ZTogUG9DaGFydE9wdGlvbnMpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgdGhpcy5fb3B0aW9ucyA9IHZhbHVlO1xuXG4gICAgICB0aGlzLnZlcmlmeUF4aXNPcHRpb25zKHRoaXMuX29wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG5cbiAgQElucHV0KCdwLXNlcmllcycpIHNldCBzZXJpZXMoZGF0YTogQXJyYXk8UG9DaGFydFNlcmllPikge1xuICAgIHRoaXMuX3NlcmllcyA9IGRhdGE7XG4gICAgdGhpcy5zZXRBbGlnbkJ5VGhlQ29ybmVycyh0aGlzLl9zZXJpZXMpO1xuICAgIHRoaXMuc2V0U2VyaWVzQnlUeXBlKHRoaXMuX3Nlcmllcyk7XG4gICAgdGhpcy5zZXRSYW5nZSh0aGlzLl9zZXJpZXMsIHRoaXMub3B0aW9ucyk7XG4gIH1cblxuICBnZXQgc2VyaWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXJpZXM7XG4gIH1cblxuICBnZXQgaXNUeXBlQ2lyY3VsYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gUG9DaGFydFR5cGUuUGllIHx8IHRoaXMudHlwZSA9PT0gUG9DaGFydFR5cGUuRG9udXQ7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1hdGhzU2VydmljZTogUG9DaGFydE1hdGhzU2VydmljZSkge31cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKGNoYW5nZXMudHlwZSB8fCBjaGFuZ2VzLmNvbnRhaW5lclNpemUpIHtcbiAgICAgIHRoaXMuc2V0Vmlld0JveCgpO1xuICAgICAgdGhpcy5zZXRTdmdTcGFjZSgpO1xuICAgIH1cbiAgfVxuXG4gIGdldENhdGVnb3JpZXNDb29yZGluYXRlcyh2YWx1ZTogQXJyYXk8bnVtYmVyPik6IHZvaWQge1xuICAgIHRoaXMuY2F0ZWdvcmllc0Nvb3JkaW5hdGVzID0gdmFsdWU7XG4gIH1cblxuICBvblNlcmllQ2xpY2soZXZlbnQ6IGFueSkge1xuICAgIHRoaXMuc2VyaWVDbGljay5lbWl0KGV2ZW50KTtcbiAgfVxuXG4gIG9uU2VyaWVIb3ZlcihldmVudDogYW55KSB7XG4gICAgdGhpcy5zZXJpZUhvdmVyLmVtaXQoZXZlbnQpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRSYW5nZShzZXJpZXM6IEFycmF5PFBvQ2hhcnRTZXJpZT4sIG9wdGlvbnM6IFBvQ2hhcnRPcHRpb25zID0ge30pOiBQb0NoYXJ0TWluTWF4VmFsdWVzIHtcbiAgICBjb25zdCBkb21haW4gPSB0aGlzLm1hdGhzU2VydmljZS5jYWxjdWxhdGVNaW5BbmRNYXhWYWx1ZXMoc2VyaWVzKTtcbiAgICBjb25zdCBtaW5WYWx1ZSA9XG4gICAgICAhb3B0aW9ucy5heGlzPy5taW5SYW5nZSAmJiBkb21haW4ubWluVmFsdWUgPiAwXG4gICAgICAgID8gMFxuICAgICAgICA6IG9wdGlvbnMuYXhpcz8ubWluUmFuZ2UgPCBkb21haW4ubWluVmFsdWVcbiAgICAgICAgPyBvcHRpb25zLmF4aXMubWluUmFuZ2VcbiAgICAgICAgOiBkb21haW4ubWluVmFsdWU7XG4gICAgY29uc3QgbWF4VmFsdWUgPSBvcHRpb25zLmF4aXM/Lm1heFJhbmdlID4gZG9tYWluLm1heFZhbHVlID8gb3B0aW9ucy5heGlzLm1heFJhbmdlIDogZG9tYWluLm1heFZhbHVlO1xuICAgIGNvbnN0IHVwZGF0ZWREb21haW5WYWx1ZXMgPSB7IG1pblZhbHVlLCBtYXhWYWx1ZSB9O1xuXG4gICAgcmV0dXJuIHsgLi4uZG9tYWluLCAuLi51cGRhdGVkRG9tYWluVmFsdWVzIH07XG4gIH1cblxuICBwcml2YXRlIHNldFN2Z1NwYWNlKCkge1xuICAgIC8vIFJlcHJlc2VudGEgdW0gcG9udG8gMkQgZGVudHJvIGRvIHZpZXdwb3J0IGRvIFNWRy4gRWxlIMOpIGEgcmVwcmVzZW50YcOnw6NvIGRvIGN1cnNvciBkbyBtb3VzZSBwYXJhIGNvbXBhcmHDp8OjbyBkZSBjb29yZGVuYWRhcyBjb20gY2FkYSBkYWRvIGRlIHPDqXJpZS5cbiAgICBjb25zdCBzdmdQb2ludCA9IHRoaXMuc3ZnRUxlbWVudC5uYXRpdmVFbGVtZW50LmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgLy8gUmV0b3JuYSB1bSBET01NYXRyaXggcmVwcmVzZW50YW5kbyBhcyBtYXRyaXplcyAyRCBlIDNEIHRyYW5zZm9ybWFkYXMgYSBwYXJ0aXIgZGFzIGNvb3JkZW5hZGFzIGRvIGVsZW1lbnRvLCBlbSByZWxhw6fDo28gYW8gZG9jdW1lbnQsIHBhcmEgY29vcmRlbmFkYXMgcmVsYXRpdmFzIGFvIHZpZXdwb3J0IGRvIFNWRy5cbiAgICAvLyDDiSB1dGlsaXphZG8gbm9zIGdyw6FmaWNvcyBkbyB0aXBvIMOhcmVhIHBhcmEgcXVlIHNlamEgcG9zc8OtdmVsIGVxdWlwYXJhciBhcyBjb29yZGVuYWRhcyBkbyBldmVudG8gY29tIGNhZGEgZGFkbyBkZSBzw6lyaWUsIHBhcmEgYXNzaW0gYXRpdmFyIG8gcG9udG8gZGUgZGFkbyBlcXVpdmFsZW50ZS5cbiAgICBjb25zdCBzdmdEb21NYXRyaXggPSB0aGlzLnN2Z0VMZW1lbnQubmF0aXZlRWxlbWVudC5nZXRTY3JlZW5DVE0oKT8uaW52ZXJzZSgpO1xuXG4gICAgdGhpcy5zdmdTcGFjZSA9IHsgc3ZnUG9pbnQsIHN2Z0RvbU1hdHJpeCB9O1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRBbGlnbkJ5VGhlQ29ybmVycyhzZXJpZXM6IEFycmF5PFBvQ2hhcnRTZXJpZT4pOiB2b2lkIHtcbiAgICB0aGlzLmFsaWduQnlUaGVDb3JuZXJzID0gc2VyaWVzLmV2ZXJ5KHNlcmllID0+IHNlcmllLnR5cGUgPT09IFBvQ2hhcnRUeXBlLkFyZWEgfHwgc2VyaWUudHlwZSA9PT0gUG9DaGFydFR5cGUuQmFyKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0UmFuZ2Uoc2VyaWVzOiBBcnJheTxQb0NoYXJ0U2VyaWU+LCBvcHRpb25zOiBQb0NoYXJ0T3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVHlwZUNpcmN1bGFyKSB7XG4gICAgICB0aGlzLnJhbmdlID0gdGhpcy5nZXRSYW5nZShzZXJpZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0U2VyaWVzQnlUeXBlKHNlcmllczogQXJyYXk8UG9DaGFydFNlcmllPikge1xuICAgIHRoaXMuc2VyaWVzQnlUeXBlID0ge1xuICAgICAgW1BvQ2hhcnRUeXBlLkFyZWFdOiBzZXJpZXMuZmlsdGVyKHNlcmllID0+IHNlcmllLnR5cGUgPT09IFBvQ2hhcnRUeXBlLkFyZWEpLFxuICAgICAgW1BvQ2hhcnRUeXBlLkNvbHVtbl06IHNlcmllcy5maWx0ZXIoc2VyaWUgPT4gc2VyaWUudHlwZSA9PT0gUG9DaGFydFR5cGUuQ29sdW1uKSxcbiAgICAgIFtQb0NoYXJ0VHlwZS5CYXJdOiBzZXJpZXMuZmlsdGVyKHNlcmllID0+IHNlcmllLnR5cGUgPT09IFBvQ2hhcnRUeXBlLkJhciksXG4gICAgICBbUG9DaGFydFR5cGUuTGluZV06IHNlcmllcy5maWx0ZXIoc2VyaWUgPT4gc2VyaWUudHlwZSA9PT0gUG9DaGFydFR5cGUuTGluZSksXG4gICAgICBbUG9DaGFydFR5cGUuRG9udXRdOiBzZXJpZXMuZmlsdGVyKHNlcmllID0+IHNlcmllLnR5cGUgPT09IFBvQ2hhcnRUeXBlLkRvbnV0KSxcbiAgICAgIFtQb0NoYXJ0VHlwZS5QaWVdOiBzZXJpZXMuZmlsdGVyKHNlcmllID0+IHNlcmllLnR5cGUgPT09IFBvQ2hhcnRUeXBlLlBpZSlcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRWaWV3Qm94KCkge1xuICAgIGNvbnN0IHsgc3ZnV2lkdGgsIHN2Z0hlaWdodCB9ID0gdGhpcy5jb250YWluZXJTaXplO1xuICAgIGNvbnN0IHZpZXdCb3hXaWR0aCA9IHRoaXMuaXNUeXBlQ2lyY3VsYXIgPyBzdmdIZWlnaHQgOiBzdmdXaWR0aDtcbiAgICAvLyBUcmF0YW1lbnRvIG5lY2Vzc8OhcmlvIHBhcmEgcXVlIG7Do28gY29ydGUgbyB2ZXRvciBuYXMgZXh0cmVtaWRhZGVzXG4gICAgY29uc3Qgb2Zmc2V0WFkgPSAxO1xuXG4gICAgdGhpcy52aWV3Qm94ID0gYCR7b2Zmc2V0WFl9IC0ke29mZnNldFhZfSAke3ZpZXdCb3hXaWR0aH0gJHt0aGlzLmNvbnRhaW5lclNpemUuc3ZnSGVpZ2h0fWA7XG4gIH1cblxuICBwcml2YXRlIHZlcmlmeUF4aXNPcHRpb25zKG9wdGlvbnM6IFBvQ2hhcnRPcHRpb25zKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzVHlwZUNpcmN1bGFyICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2F4aXMnKSkge1xuICAgICAgdGhpcy5yYW5nZSA9IHRoaXMuZ2V0UmFuZ2UodGhpcy5zZXJpZXMsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLmF4aXNPcHRpb25zID0ge1xuICAgICAgICAuLi50aGlzLmF4aXNPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zLmF4aXNcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG4iXX0=