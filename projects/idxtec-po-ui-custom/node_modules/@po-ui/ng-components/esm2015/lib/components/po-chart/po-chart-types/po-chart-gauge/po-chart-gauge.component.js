import { ChangeDetectorRef, Component, ComponentFactoryResolver, ElementRef, NgZone, Renderer2, ViewChild, ViewContainerRef } from '@angular/core';
import { PoChartCircular } from '../po-chart-circular/po-chart-circular';
import { poChartGaugeStartAngle } from '../po-chart-circular/po-chart-circular.constant';
import { PoChartGaugeTextContentComponent } from './po-chart-gauge-text-content/po-chart-gauge-text-content.component';
export class PoChartGaugeComponent extends PoChartCircular {
    /* istanbul ignore next */
    constructor(changeDetection, componentFactoryResolver, el, ngZone, renderer) {
        super(el, ngZone, renderer);
        this.changeDetection = changeDetection;
        this.componentFactoryResolver = componentFactoryResolver;
        this.chartItemStartAngle = poChartGaugeStartAngle;
        this._series = [];
    }
    set series(series) {
        this._series = this.getGaugeSerie(series);
    }
    get series() {
        return this._series;
    }
    ngAfterViewInit() {
        this.drawBasePath();
        this.createComponent();
    }
    createComponent() {
        const factory = this.componentFactoryResolver.resolveComponentFactory(PoChartGaugeTextContentComponent);
        const componentRef = this.svgContainerRef.createComponent(factory);
        const instance = componentRef.instance;
        instance.serie = this.series.length && this.series[0];
        instance.gaugeWidth = this.getGaugeBaseWidth();
        this.resizeListenerSubscription(instance);
    }
    checkGaugeValueLimits(value) {
        if (value <= 0) {
            return 0;
        }
        else if (value >= 100) {
            return 100;
        }
        else {
            return value;
        }
    }
    drawBasePath() {
        const basePath = this.el.nativeElement.querySelector('.po-chart-gauge-base-path');
        this.drawPath(basePath, this.chartItemStartAngle, 0);
    }
    getGaugeBaseWidth() {
        const basePath = this.el.nativeElement.querySelector('.po-chart-gauge-base-path');
        if (basePath) {
            return basePath.getBoundingClientRect().width;
        }
    }
    getGaugeSerie(series = []) {
        const [serie] = series;
        if (serie && typeof serie === 'object') {
            return [
                Object.assign(Object.assign({}, serie), { color: this.colors[0], value: this.checkGaugeValueLimits(serie.value) })
            ];
        }
        return [];
    }
    resizeListenerSubscription(instance) {
        this.windowResizeEmitter.subscribe(() => {
            instance.gaugeWidth = this.getGaugeBaseWidth();
            this.changeDetection.detectChanges();
        });
    }
}
PoChartGaugeComponent.decorators = [
    { type: Component, args: [{
                selector: 'po-chart-gauge',
                template: "<div #chartBody class=\"po-chart-body\">\n  <div #svgContainer class=\"po-chart-svg-container\"></div>\n\n  <div #tooltipElement *ngIf=\"!isChartGaugeType\" class=\"po-chart-tooltip po-tooltip po-invisible\">\n    <div class=\"po-tooltip-arrow po-arrow-bottom\"></div>\n    <div class=\"po-tooltip-content\">{{ tooltipText }}</div>\n  </div>\n</div>\n"
            },] }
];
PoChartGaugeComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ComponentFactoryResolver },
    { type: ElementRef },
    { type: NgZone },
    { type: Renderer2 }
];
PoChartGaugeComponent.propDecorators = {
    svgContainerRef: [{ type: ViewChild, args: ['svgContainer', { static: true, read: ViewContainerRef },] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tY2hhcnQtZ2F1Z2UuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvdWkvc3JjL2xpYi9jb21wb25lbnRzL3BvLWNoYXJ0L3BvLWNoYXJ0LXR5cGVzL3BvLWNoYXJ0LWdhdWdlL3BvLWNoYXJ0LWdhdWdlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUwsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCx3QkFBd0IsRUFDeEIsVUFBVSxFQUNWLE1BQU0sRUFDTixTQUFTLEVBQ1QsU0FBUyxFQUNULGdCQUFnQixFQUNqQixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sd0NBQXdDLENBQUM7QUFFekUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0saURBQWlELENBQUM7QUFDekYsT0FBTyxFQUFFLGdDQUFnQyxFQUFFLE1BQU0scUVBQXFFLENBQUM7QUFNdkgsTUFBTSxPQUFPLHFCQUFzQixTQUFRLGVBQWU7SUFleEQsMEJBQTBCO0lBQzFCLFlBQ1UsZUFBa0MsRUFDbEMsd0JBQWtELEVBQzFELEVBQWMsRUFDZCxNQUFjLEVBQ2QsUUFBbUI7UUFFbkIsS0FBSyxDQUFDLEVBQUUsRUFBRSxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFOcEIsb0JBQWUsR0FBZixlQUFlLENBQW1CO1FBQ2xDLDZCQUF3QixHQUF4Qix3QkFBd0IsQ0FBMEI7UUFmNUQsd0JBQW1CLEdBQVcsc0JBQXNCLENBQUM7UUFFM0MsWUFBTyxHQUE2QixFQUFFLENBQUM7SUFtQmpELENBQUM7SUFqQkQsSUFBSSxNQUFNLENBQUMsTUFBZ0M7UUFDekMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFRCxJQUFJLE1BQU07UUFDUixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7SUFDdEIsQ0FBQztJQWFELGVBQWU7UUFDYixJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDcEIsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQ3pCLENBQUM7SUFFTyxlQUFlO1FBQ3JCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyx1QkFBdUIsQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO1FBRXhHLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ25FLE1BQU0sUUFBUSxHQUFHLFlBQVksQ0FBQyxRQUFRLENBQUM7UUFFdkMsUUFBUSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3RELFFBQVEsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFFL0MsSUFBSSxDQUFDLDBCQUEwQixDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFTyxxQkFBcUIsQ0FBQyxLQUFhO1FBQ3pDLElBQUksS0FBSyxJQUFJLENBQUMsRUFBRTtZQUNkLE9BQU8sQ0FBQyxDQUFDO1NBQ1Y7YUFBTSxJQUFJLEtBQUssSUFBSSxHQUFHLEVBQUU7WUFDdkIsT0FBTyxHQUFHLENBQUM7U0FDWjthQUFNO1lBQ0wsT0FBTyxLQUFLLENBQUM7U0FDZDtJQUNILENBQUM7SUFFTyxZQUFZO1FBQ2xCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO1FBRWxGLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRU8saUJBQWlCO1FBQ3ZCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO1FBRWxGLElBQUksUUFBUSxFQUFFO1lBQ1osT0FBTyxRQUFRLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxLQUFLLENBQUM7U0FDL0M7SUFDSCxDQUFDO0lBRU8sYUFBYSxDQUFDLFNBQW1DLEVBQUU7UUFDekQsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLE1BQU0sQ0FBQztRQUV2QixJQUFJLEtBQUssSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7WUFDdEMsT0FBTztnREFFQSxLQUFLLEtBQ1IsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQ3JCLEtBQUssRUFBRSxJQUFJLENBQUMscUJBQXFCLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQzthQUVqRCxDQUFDO1NBQ0g7UUFFRCxPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFFTywwQkFBMEIsQ0FBQyxRQUEwQztRQUMzRSxJQUFJLENBQUMsbUJBQW1CLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTtZQUN0QyxRQUFRLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1lBQy9DLElBQUksQ0FBQyxlQUFlLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDdkMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDOzs7WUE1RkYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxnQkFBZ0I7Z0JBQzFCLDJXQUFzRDthQUN2RDs7O1lBbEJDLGlCQUFpQjtZQUVqQix3QkFBd0I7WUFDeEIsVUFBVTtZQUNWLE1BQU07WUFDTixTQUFTOzs7OEJBZVIsU0FBUyxTQUFDLGNBQWMsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICBFbGVtZW50UmVmLFxuICBOZ1pvbmUsXG4gIFJlbmRlcmVyMixcbiAgVmlld0NoaWxkLFxuICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBQb0NoYXJ0Q2lyY3VsYXIgfSBmcm9tICcuLi9wby1jaGFydC1jaXJjdWxhci9wby1jaGFydC1jaXJjdWxhcic7XG5pbXBvcnQgeyBQb0NoYXJ0R2F1Z2VTZXJpZSB9IGZyb20gJy4vcG8tY2hhcnQtZ2F1Z2Utc2VyaWVzLmludGVyZmFjZSc7XG5pbXBvcnQgeyBwb0NoYXJ0R2F1Z2VTdGFydEFuZ2xlIH0gZnJvbSAnLi4vcG8tY2hhcnQtY2lyY3VsYXIvcG8tY2hhcnQtY2lyY3VsYXIuY29uc3RhbnQnO1xuaW1wb3J0IHsgUG9DaGFydEdhdWdlVGV4dENvbnRlbnRDb21wb25lbnQgfSBmcm9tICcuL3BvLWNoYXJ0LWdhdWdlLXRleHQtY29udGVudC9wby1jaGFydC1nYXVnZS10ZXh0LWNvbnRlbnQuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAncG8tY2hhcnQtZ2F1Z2UnLFxuICB0ZW1wbGF0ZVVybDogJy4uL3BvLWNoYXJ0LWR5bmFtaWMtdHlwZS5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgUG9DaGFydEdhdWdlQ29tcG9uZW50IGV4dGVuZHMgUG9DaGFydENpcmN1bGFyIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG4gIEBWaWV3Q2hpbGQoJ3N2Z0NvbnRhaW5lcicsIHsgc3RhdGljOiB0cnVlLCByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pIHN2Z0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZjtcblxuICBjaGFydEl0ZW1TdGFydEFuZ2xlOiBudW1iZXIgPSBwb0NoYXJ0R2F1Z2VTdGFydEFuZ2xlO1xuXG4gIHByb3RlY3RlZCBfc2VyaWVzOiBBcnJheTxQb0NoYXJ0R2F1Z2VTZXJpZT4gPSBbXTtcblxuICBzZXQgc2VyaWVzKHNlcmllczogQXJyYXk8UG9DaGFydEdhdWdlU2VyaWU+KSB7XG4gICAgdGhpcy5fc2VyaWVzID0gdGhpcy5nZXRHYXVnZVNlcmllKHNlcmllcyk7XG4gIH1cblxuICBnZXQgc2VyaWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXJpZXM7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgcHJpdmF0ZSBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICBlbDogRWxlbWVudFJlZixcbiAgICBuZ1pvbmU6IE5nWm9uZSxcbiAgICByZW5kZXJlcjogUmVuZGVyZXIyXG4gICkge1xuICAgIHN1cGVyKGVsLCBuZ1pvbmUsIHJlbmRlcmVyKTtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLmRyYXdCYXNlUGF0aCgpO1xuICAgIHRoaXMuY3JlYXRlQ29tcG9uZW50KCk7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUNvbXBvbmVudCgpIHtcbiAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoUG9DaGFydEdhdWdlVGV4dENvbnRlbnRDb21wb25lbnQpO1xuXG4gICAgY29uc3QgY29tcG9uZW50UmVmID0gdGhpcy5zdmdDb250YWluZXJSZWYuY3JlYXRlQ29tcG9uZW50KGZhY3RvcnkpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gY29tcG9uZW50UmVmLmluc3RhbmNlO1xuXG4gICAgaW5zdGFuY2Uuc2VyaWUgPSB0aGlzLnNlcmllcy5sZW5ndGggJiYgdGhpcy5zZXJpZXNbMF07XG4gICAgaW5zdGFuY2UuZ2F1Z2VXaWR0aCA9IHRoaXMuZ2V0R2F1Z2VCYXNlV2lkdGgoKTtcblxuICAgIHRoaXMucmVzaXplTGlzdGVuZXJTdWJzY3JpcHRpb24oaW5zdGFuY2UpO1xuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0dhdWdlVmFsdWVMaW1pdHModmFsdWU6IG51bWJlcikge1xuICAgIGlmICh2YWx1ZSA8PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID49IDEwMCkge1xuICAgICAgcmV0dXJuIDEwMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZHJhd0Jhc2VQYXRoKCkge1xuICAgIGNvbnN0IGJhc2VQYXRoID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wby1jaGFydC1nYXVnZS1iYXNlLXBhdGgnKTtcblxuICAgIHRoaXMuZHJhd1BhdGgoYmFzZVBhdGgsIHRoaXMuY2hhcnRJdGVtU3RhcnRBbmdsZSwgMCk7XG4gIH1cblxuICBwcml2YXRlIGdldEdhdWdlQmFzZVdpZHRoKCkge1xuICAgIGNvbnN0IGJhc2VQYXRoID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wby1jaGFydC1nYXVnZS1iYXNlLXBhdGgnKTtcblxuICAgIGlmIChiYXNlUGF0aCkge1xuICAgICAgcmV0dXJuIGJhc2VQYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0R2F1Z2VTZXJpZShzZXJpZXM6IEFycmF5PFBvQ2hhcnRHYXVnZVNlcmllPiA9IFtdKSB7XG4gICAgY29uc3QgW3NlcmllXSA9IHNlcmllcztcblxuICAgIGlmIChzZXJpZSAmJiB0eXBlb2Ygc2VyaWUgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgLi4uc2VyaWUsXG4gICAgICAgICAgY29sb3I6IHRoaXMuY29sb3JzWzBdLFxuICAgICAgICAgIHZhbHVlOiB0aGlzLmNoZWNrR2F1Z2VWYWx1ZUxpbWl0cyhzZXJpZS52YWx1ZSlcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBwcml2YXRlIHJlc2l6ZUxpc3RlbmVyU3Vic2NyaXB0aW9uKGluc3RhbmNlOiBQb0NoYXJ0R2F1Z2VUZXh0Q29udGVudENvbXBvbmVudCkge1xuICAgIHRoaXMud2luZG93UmVzaXplRW1pdHRlci5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgaW5zdGFuY2UuZ2F1Z2VXaWR0aCA9IHRoaXMuZ2V0R2F1Z2VCYXNlV2lkdGgoKTtcbiAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0aW9uLmRldGVjdENoYW5nZXMoKTtcbiAgICB9KTtcbiAgfVxufVxuIl19