import { __decorate } from "tslib";
import { Directive, Input } from '@angular/core';
import { InputBoolean } from '../../decorators';
import { PoFieldModel } from './po-field.model';
import { requiredFailed } from './validators';
/**
 * @docsExtends PoFieldModel
 */
export class PoFieldValidateModel extends PoFieldModel {
    constructor() {
        super(...arguments);
        /**
         * @optional
         *
         * @description
         *
         * Define se a indicação de campo opcional será exibida.
         *
         * > Não será exibida a indicação se:
         * - O campo conter `p-required`;
         * - Não possuir `p-help` e/ou `p-label`.
         *
         * @default `false`
         */
        this.optional = false;
        /**
         * @optional
         *
         * @description
         *
         * Indica que o campo será obrigatório.
         *
         * @default `false`
         */
        this.required = false;
    }
    validate(abstractControl) {
        if (requiredFailed(this.required, this.disabled, abstractControl.value)) {
            return {
                required: {
                    valid: false
                }
            };
        }
        return this.extraValidation(abstractControl);
    }
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
    validateModel() {
        if (this.onValidatorChange) {
            this.onValidatorChange();
        }
    }
}
PoFieldValidateModel.decorators = [
    { type: Directive }
];
PoFieldValidateModel.propDecorators = {
    optional: [{ type: Input, args: ['p-optional',] }],
    required: [{ type: Input, args: ['p-required',] }]
};
__decorate([
    InputBoolean()
], PoFieldValidateModel.prototype, "optional", void 0);
__decorate([
    InputBoolean()
], PoFieldValidateModel.prototype, "required", void 0);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tZmllbGQtdmFsaWRhdGUubW9kZWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy91aS9zcmMvbGliL2NvbXBvbmVudHMvcG8tZmllbGQvcG8tZmllbGQtdmFsaWRhdGUubW9kZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBR2pELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNoRCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDaEQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUU5Qzs7R0FFRztBQUVILE1BQU0sT0FBZ0Isb0JBQXdCLFNBQVEsWUFBZTtJQURyRTs7UUFFRTs7Ozs7Ozs7Ozs7O1dBWUc7UUFDa0MsYUFBUSxHQUFZLEtBQUssQ0FBQztRQUUvRDs7Ozs7Ozs7V0FRRztRQUNrQyxhQUFRLEdBQVksS0FBSyxDQUFDO0lBMkJqRSxDQUFDO0lBdkJDLFFBQVEsQ0FBQyxlQUFnQztRQUN2QyxJQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsZUFBZSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3ZFLE9BQU87Z0JBQ0wsUUFBUSxFQUFFO29CQUNSLEtBQUssRUFBRSxLQUFLO2lCQUNiO2FBQ0YsQ0FBQztTQUNIO1FBRUQsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFFRCx5QkFBeUIsQ0FBQyxFQUFPO1FBQy9CLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLENBQUM7SUFDOUIsQ0FBQztJQUVELGFBQWE7UUFDWCxJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtZQUMxQixJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztTQUMxQjtJQUNILENBQUM7OztZQWxERixTQUFTOzs7dUJBZVAsS0FBSyxTQUFDLFlBQVk7dUJBV2xCLEtBQUssU0FBQyxZQUFZOztBQVhrQjtJQUFmLFlBQVksRUFBRTtzREFBMkI7QUFXMUI7SUFBZixZQUFZLEVBQUU7c0RBQTJCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IElucHV0Qm9vbGVhbiB9IGZyb20gJy4uLy4uL2RlY29yYXRvcnMnO1xuaW1wb3J0IHsgUG9GaWVsZE1vZGVsIH0gZnJvbSAnLi9wby1maWVsZC5tb2RlbCc7XG5pbXBvcnQgeyByZXF1aXJlZEZhaWxlZCB9IGZyb20gJy4vdmFsaWRhdG9ycyc7XG5cbi8qKlxuICogQGRvY3NFeHRlbmRzIFBvRmllbGRNb2RlbFxuICovXG5ARGlyZWN0aXZlKClcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQb0ZpZWxkVmFsaWRhdGVNb2RlbDxUPiBleHRlbmRzIFBvRmllbGRNb2RlbDxUPiBpbXBsZW1lbnRzIFZhbGlkYXRvciB7XG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIERlZmluZSBzZSBhIGluZGljYcOnw6NvIGRlIGNhbXBvIG9wY2lvbmFsIHNlcsOhIGV4aWJpZGEuXG4gICAqXG4gICAqID4gTsOjbyBzZXLDoSBleGliaWRhIGEgaW5kaWNhw6fDo28gc2U6XG4gICAqIC0gTyBjYW1wbyBjb250ZXIgYHAtcmVxdWlyZWRgO1xuICAgKiAtIE7Do28gcG9zc3VpciBgcC1oZWxwYCBlL291IGBwLWxhYmVsYC5cbiAgICpcbiAgICogQGRlZmF1bHQgYGZhbHNlYFxuICAgKi9cbiAgQElucHV0KCdwLW9wdGlvbmFsJykgQElucHV0Qm9vbGVhbigpIG9wdGlvbmFsOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogSW5kaWNhIHF1ZSBvIGNhbXBvIHNlcsOhIG9icmlnYXTDs3Jpby5cbiAgICpcbiAgICogQGRlZmF1bHQgYGZhbHNlYFxuICAgKi9cbiAgQElucHV0KCdwLXJlcXVpcmVkJykgQElucHV0Qm9vbGVhbigpIHJlcXVpcmVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBvblZhbGlkYXRvckNoYW5nZTtcblxuICB2YWxpZGF0ZShhYnN0cmFjdENvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMge1xuICAgIGlmIChyZXF1aXJlZEZhaWxlZCh0aGlzLnJlcXVpcmVkLCB0aGlzLmRpc2FibGVkLCBhYnN0cmFjdENvbnRyb2wudmFsdWUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXF1aXJlZDoge1xuICAgICAgICAgIHZhbGlkOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmV4dHJhVmFsaWRhdGlvbihhYnN0cmFjdENvbnRyb2wpO1xuICB9XG5cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogYW55KSB7XG4gICAgdGhpcy5vblZhbGlkYXRvckNoYW5nZSA9IGZuO1xuICB9XG5cbiAgdmFsaWRhdGVNb2RlbCgpIHtcbiAgICBpZiAodGhpcy5vblZhbGlkYXRvckNoYW5nZSkge1xuICAgICAgdGhpcy5vblZhbGlkYXRvckNoYW5nZSgpO1xuICAgIH1cbiAgfVxuXG4gIGFic3RyYWN0IGV4dHJhVmFsaWRhdGlvbihjOiBBYnN0cmFjdENvbnRyb2wpOiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xufVxuIl19