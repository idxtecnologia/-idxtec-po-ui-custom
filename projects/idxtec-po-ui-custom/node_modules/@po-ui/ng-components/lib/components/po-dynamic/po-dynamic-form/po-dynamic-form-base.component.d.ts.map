{"version":3,"file":"po-dynamic-form-base.component.d.ts","sources":["po-dynamic-form-base.component.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { EventEmitter } from '@angular/core';\nimport { NgForm } from '@angular/forms';\nimport { PoDynamicFormField } from './po-dynamic-form-field.interface';\n/**\n *\n * @description\n *\n * Componente para criação de formulários dinâmicos a partir de uma lista de objetos.\n *\n * Também é possível verificar se o formulário está válido e informar valores para a exibição de informações.\n */\nexport declare class PoDynamicFormBaseComponent {\n    /**\n     * @optional\n     *\n     * @description\n     *\n     * Nome da propriedade, atribuída ao `PoDynamicFormField.property`, que iniciará o campo com foco.\n     */\n    autoFocus?: string;\n    /**\n     * @description\n     *\n     * Coleção de objetos que implementam a interface `PoDynamicFormField`, para definição dos campos que serão criados\n     * dinamicamente.\n     *\n     * > Ex: `[ { property: 'name' } ]`\n     *\n     * Regras de tipagem e criação dos componentes:\n     *\n     * - Caso o *type* informado seja *boolean* o componente criado será o `po-switch`.\n     * - Caso o *type* informado seja *currency* e não seja informado um *mask* ou *pattern* o componente criado será o `po-decimal`,\n     * caso seja informado um *mask* ou *pattern* o componente criado será o `po-input`.\n     * - Caso o *type* informado seja *number* e não seja informado um *mask* ou *pattern* o componente criado será o `po-number`, caso seja\n     * informado um *mask* ou *pattern* o componente criado será o `po-input`.\n     * - Caso a lista possua a propriedade `options` e a mesma possua até 3 itens o componente criado será o `po-radio-group`\n     * ou `po-checkbox-group` se informar a propriedade `optionsMulti`.\n     * - Caso a mesma possua 3 ou mais itens, será criado o componente `po-select` ou, `po-multiselect` se a propriedade `optionsMulti`\n     * for verdadeira.\n     * - Caso o *type* informado seja *date* ou *datetime* o componente criado será o `po-datepicker`.\n     * - Caso seja informado a propriedade `optionsService` o componente criado será o `po-combo`.\n     * - Caso o *type* informado seja *time* o componente criado será um `po-input` podendo receber um *mask* para formatar\n     * o valor exibido, caso não seja informado um *mask* o componente será criado com a máscara '99:99' por padrão.\n     * - Caso a lista possua a propriedade `rows` e esta seja definida com valor maior ou igual a 3 o componente criado será\n     * o `po-textarea`, caso o valor da propriedade `rows` seja menor que 3 o componente criado será o `po-input`.\n     * - Caso seja informada a propriedade `secret` o componente criado será o `po-password`.\n     * - Caso o *type* informado seja *string* o componente criado será o `po-input`.\n     *\n     * @default `[]`\n     */\n    fields: Array<PoDynamicFormField>;\n    /**\n     * Objeto que será utilizado como valor para exibir as informações, será recuperado e preenchido através do atributo *property*\n     * dos objetos contidos na propridade `p-fields`.\n     *\n     * Pode iniciar com valor ou apenas com um objeto vazio que será preenchido conforme descrito acima.\n     *\n     * > Ex: `{ name: 'po' }`\n     */\n    value: any;\n    /**\n     * @optional\n     *\n     * @description\n     *\n     * Na inicialização do componente será repassado o objeto de formulário utilizado no componente,\n     * podendo ser utilizado para validações e/ou detecção de mudança dos valores.\n     *\n     * Portanto existem duas maneiras de recuperar o formulário,\n     * através de *template reference* e através do *output*, veja os exemplos abaixo:\n     *\n     * > *template reference*\n     *\n     * ```html\n     *  <po-dynamic-form #dynamicForm>\n     *  </po-dynamic-form>\n     *\n     *  <po-button p-label=\"Adicionar\" [p-disabled]=\"dynamicForm?.form.invalid\">\n     *  </po-button>\n     *\n     * ```\n     *\n     * > *Output*\n     *\n     * ```html\n     *  ...\n     *  <po-dynamic-form (p-form)=\"getForm($event)\">\n     *  </po-dynamic-form>\n     *\n     *  <po-button p-label=\"Adicionar\" [p-disabled]=\"dynamicForm?.invalid\">\n     *  </po-button>\n     *  ...\n     *\n     * ```\n     *\n     * ```ts\n     *  ...\n     *\n     *  export class AppComponent {\n     *\n     *    dynamicForm: NgForm;\n     *\n     *    getForm(form: NgForm) {\n     *      this.dynamicForm = form;\n     *    }\n     *\n     *  }\n     * ```\n     *\n     * > Caso a propriedade `p-group-form` for verdadeira não será repassado o formulário, pois o mesmo utilizará\n     * o formulário pai.\n     */\n    formOutput: EventEmitter<NgForm>;\n    /**\n     * Função ou serviço que será executado na inicialização do componente.\n     *\n     * A propriedade aceita os seguintes tipos:\n     * - `string`: *Endpoint* usado pelo componente para requisição via `POST`.\n     * - `function`: Método que será executado.\n     *\n     * Ao ser executado, irá receber como parâmetro o objeto informado no `p-value`.\n     *\n     * O retorno desta função deve ser do tipo [PoDynamicFormLoad](documentation/po-dynamic-form#po-dynamic-form-load),\n     * onde o usuário poderá determinar as novas atualizações dos campos, valores e determinar o campo a ser focado.\n     *\n     * Por exemplo:\n     *\n     * ```\n     * onLoadFields(): PoDynamicFormLoad {\n     *\n     *   return {\n     *     value: { cpf: undefined },\n     *     fields: [\n     *       { property: 'cpf' }\n     *     ],\n     *     focus: 'cpf'\n     *   };\n     * }\n     *\n     * ```\n     * Para referenciar a sua função utilize a propriedade `bind`, por exemplo:\n     * ```\n     *  [p-load]=\"onLoadFields.bind(this)\"\n     * ```\n     */\n    load?: string | Function;\n    /**\n     * Função ou serviço para validar as **mudanças do formulário**.\n     *\n     * A propriedade aceita os seguintes tipos:\n     * - `string`: *Endpoint* usado pelo componente para requisição via `POST`.\n     * - `function`: Método que será executado.\n     *\n     * Ao ser executado, irá receber como parâmetro um objeto com o nome da propriedade\n     * alterada e o novo valor, conforme a interface `PoDynamicFormFieldChanged`:\n     *\n     * ```\n     * { property: 'property name', value: 'new value' }\n     * ```\n     *\n     * O retorno desta função deve ser do tipo [PoDynamicFormValidation](documentation/po-dynamic-form#po-dynamic-form-validation),\n     * onde o usuário poderá determinar as novas atualizações dos campos.\n     * Por exemplo:\n     *\n     * ```\n     * onChangeFields(changeValue): PoDynamicFormValidation {\n     *\n     * if (changeValue.property === 'state') {\n     *\n     *   return {\n     *     value: { city: undefined },\n     *     fields: [\n     *       { property: 'city', options: this.getCity(changeValue.value.state) }\n     *     ],\n     *     focus: 'city'\n     *   };\n     * }\n     *\n     * ```\n     * Para referenciar a sua função utilize a propriedade `bind`, por exemplo:\n     * ```\n     *  [p-validate]=\"this.myFunction.bind(this)\"\n     * ```\n     *\n     * > Se houver uma lista de campos para validação definida em `p-validate-fields`, a propriedade `validate` só receberá o disparo para os campos equivalentes.\n     */\n    validate?: string | Function;\n    /**\n     * @optional\n     *\n     * @description\n     *\n     * Lista que define os campos que irão disparar o validate do form.\n     */\n    validateFields?: Array<string>;\n    private _groupForm?;\n    /**\n     * @optional\n     *\n     * @description\n     * Ao informar esta propriedade, o componente passará a utilizar o formulário pai para criar os `FormControl`\n     * e com isso é possível recuperar o valor do formulário e suas validações a partir do formulário pai.\n     *\n     * ```html\n     * <form #parentForm=\"ngForm\">\n     *\n     *   <po-dynamic-form p-group-form [p-fields]=\"fields\"></po-dynamic-form>\n     *\n     *  <po-button p-label=\"Adicionar\" [p-disabled]=\"parentForm.invalid\"></po-button>\n     * </form>\n     * ```\n     */\n    set groupForm(value: boolean);\n    get groupForm(): boolean;\n}\n"]}